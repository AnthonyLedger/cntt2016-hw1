# CharacterBoard
## 题目描述
很久很久以前，有一个活泼可爱的小朋友，他拥有一个$$1000000000$$行$$W$$列的棋盘，行从上至下以$$0..999999999$$编号，列从左至右以$$0..W-1$$编号。

后来，有一个长者给了他一个长度为$$L$$的字符串$$s[0..L-1]$$，并让小朋友以以下伪代码去填充这个棋盘$$a[1000000000][W]$$。
```C++
int cursor = 0;
for (int i = 0; i < 1000000000; i++)
    for (int j = 0; j < W; j++)
    {
        a[i][j] = s[cursor];
        cursor = (cursor + 1) % L;
    }
```
接着，小朋友在大棋盘中取出一个以$$(i0,j0)$$为左上角，行数为$$N$$，列数为$$M$$的子矩阵$$fragment[N][M]$$。

现在已知$$i0,~j0,~W$$，以及取出的子矩阵$$fragment[N][M]$$，而对于那个用于循环节的字符串$$s$$，连长度$$L$$都不知道，更别提内容了，只知道 $$L\le W$$，且$$s$$只含有小写字母。小朋友想要猜出这个字符串$$s$$究竟是啥。

于是问你$$s$$有多少种可能的值，答案$$mod~1000000009$$。
## 数据范围
$$1\le N,M\le 10$$

$$1\le W \le 1000000000$$

$$0\le i0 \le 1000000000-N$$

$$0\le j0\le W-M$$
## 算法一
很容易发现，$$fragment[x][y]=a[x+i0][y+j0]=s[((x+i0)*W+y+j0)~mod~L]$$

也就是说，$$fragment$$的每一个格子，都是对$$s$$上一个特定格子的限制。

观察得，$$i0$$和$$j0$$的存在没有任何意义，因为$$i0$$和$$j0$$的改变只会导致$$s$$串的旋转，那么不妨令$$i0=j0=0$$，即$$fragment[x][y]=s[(x*W+y)~mod~L]$$。

枚举$$L$$，考虑一个理想化的情况：如果$$fragment$$中的各个元素所限制的$$s$$中的位置各不重复（说人话便是：只要$$0\le x0,x1<N$$且$$0\le y0,y1<M$$且$$(x0*W+y0)~mod~L=(x1*W+y1)~mod~L$$，必有$$x0=x1$$且$$y0=y1$$），则$$s$$中有$$N*M$$个位置是被钦定的，其余$$L-N*M$$个位置是绝对自由的，则这个$$L$$对答案的贡献是$$26^{L-N*M}$$。

然而现实并没有这么理想。

如果$$s$$上的一个位置同时受到$$fragment$$中多个元素的限制，那么：...

.......case 1:这多个限制有矛盾，那个这个$$L$$对答案的贡献就是$$0$$。

.......case 2:如果这多个限制没有矛盾，多个限制就合并成一个限制。

对于一个不理想的$$L$$，如果出现了矛盾，这个$$L$$就无法贡献答案，否则，设$$N*M$$个限制合并后变成了R个，则对答案的贡献就是$$26^{L-R}$$。

那么就得到了一个枚举$$L$$，然后对于每一个$$L$$，都用std::map < int, char >来对限制进行判矛盾和去重，时间复杂度为$$O(WNMlog(NM))$$的算法。
## 算法二
看！算法一太简单粗暴了！$$L$$这种$$1e9$$级别的数字怎么能枚举呢？

然而呢，上述的*不理想的*$$L$$的个数是较少的，对于$$fragment$$上的*一对*元素$$(x0,y0)$$和$$(x1,y1)$$，想象把大棋盘$$a$$拉直成条状，则这对元素在拉直后的条状棋盘上相距$$abs((x1-x0)*W+(y1-y0))$$，那么只要$$L$$是$$abs((x1-x0)*W+(y1-y0))$$的某个约数，$$L$$就是不理想的。

把所有不理想的$$L$$单独按照算法一的简单粗暴的方法统计答案，剩下的$$L$$都是理想的，可以用（公比为$$26$$的）等比数列求和的方法，成段地统计答案。

*我的题解写完了，谢谢大家的观看！*
