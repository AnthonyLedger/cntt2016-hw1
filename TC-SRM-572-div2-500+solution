#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;

class EllysBulls
{
	public:
	string a[111]={};
	int b[111]={};
	int n;
	int sum=0;
	string t;
	string ans;
	bool err=0,err2=0;
	void check(int s)
	{
		int c[111]={};
		for(int i=0;i<n;i++)
			for(int j=0;j<s;j++)
				if(t[j]==a[i][j])
					c[i]++;
		int tem=a[1].size()-s;
		for(int i=0;i<n;i++)
			if(c[i]>b[i]||b[i]-c[i]>tem)
				err=1;
		if(tem==0&&!err)
		{
				if(sum==1)
					err2=1;
				else
					ans=t,sum=1;
		}
	}
	void dfs(int s)
	{
		if(s==a[0].size())
			return;
		for(char i='0';i<='9';i++)
		{
			t[s]=i;
			check(s+1);
			if(err2)//存在多个字符串满足条件
				return;
			if(err)//当前字符确定后，后面的字符无论如何都不会满足条件
			{err=0;
			continue;
			}
			else
				dfs(s+1);
		}
	}
	string getNumber(vector <string> guesses,vector <int> bulls)
	{
		n=guesses.size();
		printf("%d\n",n);
		for(int i=0;i<n;i++)
			b[i]=bulls[i],a[i]=guesses[i];
		t=a[0];
		dfs(0);
		if(err2)
		return "Ambiguity";
		else if(sum==0)
		return "Liar";
		else
		return ans;
	}
};
/*
这道题就是一个暴力搜索，使用dfs进行搜索，但是直接枚举所有情况肯定不行，这需要进行剪枝，然后才能通过。
剪枝是这样的：
如果当前已经确定的部分超出了一些字符串的符合个数，则说明这个字符串一定不是结果，就直接return，停止下一层递归。
如果在假定后面没搜到的字符都符合的情况下依然不够，也可以说明这不是结果，直接return，停止下一次递归。
*/
